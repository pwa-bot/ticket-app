# Spec: Dashboard Write Actions via PR-based Git Changes (v1.1)

## Goal

Make the dashboard read/write without breaking the North Star:

* Git is authoritative
* Ticket Protocol remains the source of truth
* Dashboard writes happen by creating PRs that modify ticket files (and index.json)
* UI reflects changes immediately as **pending** until PR merges

This enables:

* Drag-and-drop state changes
* Inline edits (labels, assignee, reviewer, priority)
* Safe team workflows
* Agent orchestration aligned with merged truth

---

## Scope (v1.1)

### Supported write actions

1. **State transitions** (drag or dropdown)
2. **Labels** (add/remove)
3. **Priority** (p0â€“p3)
4. **Assignee** (human:<slug> or agent:<slug>)
5. **Reviewer** (human:<slug> or agent:<slug>)

Optional if time:

6. **Title** edit (careful, affects branch slug)
7. **Blocked reason** helper (adds label and template note)

Out of scope:

* Editing markdown body in dashboard (keep in Git for now)
* Approvals UI separate from GitHub
* Policy enforcement beyond "can we auto-merge this PR"

---

## UX Requirements

### Board interaction patterns

* Board route: `/space/:owner/:repo` (or `/board/:owner/:repo` if you stick with board prefix)
* Ticket detail deep link: `/space/:owner/:repo/t/:ticketId`

### Pending changes model (required)

When a user triggers a write action:

* The dashboard does **NOT** immediately change canonical state
* It creates a **Ticket Change PR**
* The ticket card shows:
  * original state pill (canonical)
  * a pending badge: `ready â†’ in_progress (pending)`
  * link to PR
* When PR merges:
  * canonical state updates
  * pending badge disappears
* If PR fails/conflicts:
  * show `pending failed`
  * offer retry / open PR / discard

### Drag and drop

* Dragging between columns triggers a state change PR.
* If invalid transition, UI blocks and shows reason.

### Inline edits on ticket detail (modal)

* Label add/remove
* Assignee
* Reviewer
* Priority

Each action triggers a PR (or batches changes into one PR, see batching rule below).

### Batching rule (simple)

* Default: 1 user action = 1 PR (simpler)
* Enhancement: if multiple edits happen within 30 seconds, batch into one PR
* Only implement if easy

---

## State Machine (must match protocol + CLI)

States:

* backlog
* ready
* in_progress
* blocked
* done

Allowed transitions:

* backlog -> ready, blocked
* ready -> in_progress, blocked
* in_progress -> done, blocked, ready
* blocked -> ready, in_progress
* done -> none

Dashboard must enforce these before creating PR.

---

## GitHub Write Model

### Ticket Change PR contents

Every PR created by dashboard must include:

* `.tickets/tickets/<ULID>.md` (frontmatter edits only)
* `.tickets/index.json` updated deterministically

No other files.

### Branch naming for ticket-change PRs

Use a distinct prefix to avoid collisions with code branches:

* `ticket-change/<short_id>/<timestamp-or-random>`

Example:

* `ticket-change/01arz3nd/20260217-183000`

### PR title convention

* `[TK-<short_id>] ticket change: <summary>`

Example:

* `[TK-01ARZ3ND] ticket change: ready â†’ in_progress`

### PR body template

Include:

* Ticket link (dashboard deep link)
* Canonical change summary
* Old -> new values
* Note: "This PR is generated by ticket.app dashboard"

---

## Auto-merge policy (v1.1)

Auto-merge is optional but recommended for UX.

Default behavior:

* Create PR
* If repo allows auto-merge AND PR has no required reviewers AND checks pass (if any), enable auto-merge
* Otherwise leave PR open and show "awaiting merge"

Important:

* Never bypass branch protection
* Never merge if repo requires approvals

UI should show:

* Auto-merge enabled (pending checks)
* Waiting for review
* Waiting for checks
* Merge blocked by conflict

---

## Backend/API Requirements (ticket.app)

### Endpoints (internal)

Assume Next.js + server routes.

#### 1. Create change PR

`POST /api/repos/:owner/:repo/tickets/:ticketId/changes`

Body:

```json
{
  "changes": {
    "state": "in_progress",
    "priority": "p1",
    "labels_add": ["needs-input"],
    "labels_remove": ["wip"],
    "assignee": "agent:openclaw",
    "reviewer": "human:mathieu"
  },
  "mode": "single"
}
```

Response:

```json
{
  "ok": true,
  "data": {
    "pr_url": "...",
    "pr_number": 123,
    "branch": "ticket-change/01arz3nd/...",
    "status": "pending_merge"
  }
}
```

#### 2. List pending changes for repo

`GET /api/repos/:owner/:repo/pending-changes`

Returns PRs created by dashboard, mapped to ticket ids.

#### 3. Get ticket (existing)

* fetch index.json
* fetch ticket file as needed

### GitHub operations inside create change PR

Steps:

1. Fetch latest default branch SHA
2. Create branch ref
3. Read ticket file contents
4. Apply frontmatter patch:
   * state/priority/labels/assignee/reviewer
   * preserve unknown keys and x_ticket semantically
5. Rebuild index.json deterministically:
   * simplest: load current index.json and patch the entry
   * safer: rebuild by scanning all ticket files is expensive via API
   * v1.1 approach: patch index.json entry + resort
6. Commit both files to branch
7. Create PR
8. Optionally enable auto-merge if allowed

Notes:

* Keep patches minimal, no body edits.

---

## Deterministic index.json update strategy (v1.1)

Do not rebuild the entire index via GitHub API (too slow).

Instead:

* Load existing `.tickets/index.json`
* Find matching entry by `id`
* Apply changes to that entry
* Re-sort tickets per protocol ordering
* Update `generated_at` (use current time)
* Write back file

If index is missing or ticket entry not found:

* fail with clear error: "index missing or out of sync"
* UI suggests: run CLI `ticket rebuild-index` and push, then retry

---

## Webhooks / refresh

v1.1 minimal:

* Poll PR status on interval (15â€“30s) for pending PRs
* When PR merges, re-fetch index.json and refresh board

v1.2:

* GitHub webhook on push and pull_request events for realtime updates

---

## Agent behavior (OpenClaw integration)

For v1.1, agents operate on merged truth:

* Agents do not act on dashboard PR branches
* Agents pull main and observe new ticket state
* Agents can also watch for PR comments if you add that later

---

# Frontmatter Patch Algorithm Spec

## Goal

Apply a small patch to a ticket file's YAML frontmatter without:

* dropping unknown keys
* dropping `x_ticket`
* modifying the Markdown body
* changing unrelated formatting more than necessary

We require **semantic preservation**, not byte-for-byte preservation.

## Inputs

* `ticketPath`: `.tickets/tickets/<ULID>.md`
* `rawTicketFile`: full Markdown file content string
* `patch`: object with optional fields:
  * `state`
  * `priority`
  * `labels_add` / `labels_remove` / `labels_replace` (choose one mode)
  * `assignee` (string or null)
  * `reviewer` (string or null)
  * optionally `title` (string)
* `protocolRules`: valid states, valid transitions, label normalization, actor format validation

## Output

* `newRawTicketFile`: updated Markdown file content string

## Constraints

* Frontmatter MUST remain at top of file, delimited by `---`.
* Preserve unknown keys and nested structures.
* Preserve `x_ticket` object as-is unless patch explicitly targets it (v1.1: never target it).
* Preserve Markdown body exactly as string (no reflow).

## Algorithm (language-agnostic)

### Step A: Parse frontmatter safely

1. Find first delimiter:
   * File must start with `---\n` or `---\r\n`.
   * If not present, return error `frontmatter_missing`.
2. Find closing delimiter:
   * Next occurrence of `\n---\n` or `\r\n---\r\n` (delimiter on its own line).
   * Extract:
     * `yamlText` between delimiters
     * `bodyText` after closing delimiter (keep exact)
3. Parse YAML into an object `fm` using a YAML parser that preserves:
   * mapping keys
   * scalar types
   * arrays

You do not need AST preservation, semantic preservation is enough.

If parse fails, return `frontmatter_invalid_yaml`.

### Step B: Validate required keys exist

Ensure:

* `id`, `title`, `state`, `priority`, `labels` exist
* `labels` is array
* `id` matches filename ULID (case-insensitive check ok, but write canonical uppercase)

If invalid, return `frontmatter_invalid_required_fields`.

### Step C: Validate patch against protocol

1. If patch includes `state`:
   * Validate target state in enum.
   * Validate transition is allowed from current `fm.state` to patch.state using protocol transition table.
   * If invalid, return `invalid_transition`.
2. If patch includes `priority`:
   * Validate in `p0`..`p3` (case-insensitive input ok).
   * Write lowercase canonical.
3. Labels patch rules:
   * Normalize labels to lowercase, trim.
   * Reject labels with spaces.
   * De-duplicate on write.

Support three modes:

* `labels_replace`: replace all labels
* `labels_add` + `labels_remove`: patch existing labels
* no labels change: leave as-is

If mixed modes provided, return `invalid_labels_patch`.

4. Actor fields:
   * assignee/reviewer values must match `{type}:{slug}` with allowed types `human|agent` and slug regex.
   * If null passed, remove the key entirely (preferred) or set null consistently. Choose one. Recommendation: remove key when cleared to keep files minimal.

### Step D: Apply patch to frontmatter object

* Update only specified fields.
* Do not touch unknown keys.
* Do not touch `x_ticket`.

Rules for fields:

* state: lowercase string
* priority: lowercase string
* labels: array of lowercase strings, de-duped, preserve existing order where possible
* assignee/reviewer:
  * if provided string, set `fm.assignee = string`
  * if null, delete `fm.assignee`
* title:
  * only if supported in v1.1. If included, set `fm.title = <string>` trimmed.

### Step E: Serialize YAML with stable conventions

Serialize `fm` back to YAML with these conventions:

* Use 2-space indentation
* Use `\n` line endings in YAML output (acceptable even if file uses CRLF elsewhere)
* Keep keys in a stable order for top-level known keys first, then others:
  1. id
  2. title
  3. state
  4. priority
  5. labels
  6. assignee (if present)
  7. reviewer (if present)
  8. x_ticket (if present)
  9. remaining keys (lexicographic)

This reduces noisy diffs without being byte-perfect.

### Step F: Reconstruct file

Construct:

* `---\n`
* `<yamlSerialized>\n`
* `---\n`
* `<bodyText>` exactly as extracted, no modification

Return the new file string.

## Errors (map to UI)

* `frontmatter_missing`
* `frontmatter_invalid_yaml`
* `frontmatter_invalid_required_fields`
* `invalid_transition`
* `invalid_state`
* `invalid_priority`
* `invalid_labels_patch`
* `invalid_actor`

---

# UI Component Spec (Pending Changes, Failures, PR Status)

## Goal

Make dashboard "feel" interactive while staying honest:

* Git is authoritative
* Changes are pending until PR merges
* Users can always click to GitHub to resolve issues

## Data model needed in UI

For each ticket row/card, enrich with:

* `canonical`: current state from index.json
* `pendingChange`: optional object
  * `type`: state_change | metadata_change
  * `summary`: string (e.g., `ready â†’ in_progress`)
  * `prUrl`
  * `prNumber`
  * `status`: one of:
    * `creating_pr`
    * `pending_checks`
    * `waiting_review`
    * `mergeable`
    * `auto_merge_enabled`
    * `merged`
    * `conflict`
    * `failed`
  * `error`: optional { code, message }
  * `createdAt`
  * `mergeSignals` (optional):
    * `ciStatus`: pass | fail | running | unknown
    * `reviewRequired`: boolean
    * `requiredReviewers`: list of handles
    * `approvalsCount`
    * `blockReason`: string if blocked

## Components

### A) PendingBadge (small pill)

Shown when a pending change exists.

States:

* Creating PR: "Creating PRâ€¦"
* Pending checks: "Pending checks"
* Waiting review: "Waiting review"
* Auto-merge enabled: "Auto-merge enabled"
* Conflict: "Conflict"
* Failed: "Failed"
* Merged: disappears (or briefly show "Merged" toast)

Badge content examples:

* `ready â†’ in_progress (pending)`
* `labels updated (pending)`
* `assigned reviewer (pending)`

Always include a clickable PR link icon.

### B) PRStatusChip

A compact status chip with icon:

* Checks: âœ…/âŒ/â³
* Review: ðŸ‘¤ required
* Merge: ðŸ”€ mergeable
* Conflict: âš ï¸

Hover tooltip shows:

* PR number
* current check status
* required reviewers list
* last update time

### C) TicketCard (board) and TicketRow (table)

Both should show:

* canonical state pill
* priority
* title
* repo badge
* PR status chip
* pending badge if present

Board behavior:

* Dragging triggers "create change PR"
* While pending, card remains in original column but shows pending badge.
* Optionally show a ghost card in the target column labeled "pending" (nice-to-have, but not required).

Recommendation: keep it simple, no ghost card. Just badge.

### D) ChangeActionPanel (in ticket detail modal)

Buttons:

* "Move state" dropdown
* "Set priority"
* "Edit labels"
* "Assign"
* "Set reviewer"

Each action triggers PR creation.

After action:

* show inline "PR created" with link
* show pending badge

### E) ErrorBanner (when PR creation fails)

If backend returns error:

* Show banner with error message and recovery steps.

Recovery messaging:

* If index out of sync:
  * "Index is missing or out of sync. Run `ticket rebuild-index` and push, then retry."
* If invalid transition:
  * "Invalid transition: ready â†’ done is not allowed."
* If GitHub permissions missing:
  * "Missing permissions to create branches/PRs. Reconnect GitHub or ask an admin."

## UX flows

### Flow 1: Drag state change

1. User drags ticket from ready to in_progress.
2. UI immediately sets pendingChange status "creating_pr".
3. Backend creates PR, returns PR URL.
4. UI updates badge to "ready â†’ in_progress (pending)" and status "pending_checks" or "waiting_review".
5. Poll PR status every 15â€“30 seconds for this PR.
6. When merged:
   * refresh index.json
   * ticket moves columns
   * show toast "Moved to in_progress"

### Flow 2: Inline metadata change

Same flow, summary becomes "labels updated" or "priority p1 â†’ p0".

### Flow 3: Failure or conflict

If PR creation fails:

* Show error banner and keep canonical unchanged.

If PR conflicts:

* Show status "Conflict" with CTA:
  * "Open PR" (GitHub)
  * "Retry" (creates a new PR on latest main)
  * "Dismiss" (removes pending UI, does not change Git)

## Polling and refresh

* Maintain a small "pending PRs" queue in client state.
* Poll PR status endpoints for those only.
* When a PR merges, refresh index.json once and clear that PR from queue.

## Copy guidelines

Avoid implying canonical state changed before merge. Use words like:

* pending
* awaiting merge
* awaiting checks
* awaiting review

Never show the card in the new column as if it already changed unless merged.

---

# Deterministic index.json Patch Algorithm (v1.1)

## Goal

Update `.tickets/index.json` efficiently via GitHub API without scanning all ticket files.

We do:

* load existing index.json
* patch the matching ticket entry
* re-sort deterministically per protocol
* write back index.json

If index is missing/out of sync, fail with a clear error.

## Inputs

* `rawIndexJson`: string contents of `.tickets/index.json`
* `ticketId`: full ULID (26 chars, uppercase)
* `patch`: same patch object used for frontmatter (state/priority/labels/assignee/reviewer/title optional)
* `config`: `id_prefix`, workflow name, and canonical state ordering

## Output

* `newRawIndexJson`: updated string JSON content

## Algorithm

### Step A: Parse and validate envelope

1. `idx = JSON.parse(rawIndexJson)`
2. Validate required top-level fields:
   * `format_version` exists and is 1
   * `tickets` exists and is an array

If invalid:

* error `index_invalid_format`

### Step B: Locate ticket entry

Find entry where `entry.id === ticketId` (case-insensitive compare ok for read; write canonical uppercase).

If not found:

* error `index_missing_ticket_entry`

### Step C: Apply patch to entry

Update only the fields impacted by patch:

* state: lowercase
* priority: lowercase
* labels: array lowercase deduped
* assignee/reviewer: string or null
* title: string (if supported)
* display_id and short_id must remain correct
* path must remain unchanged

Do not modify unknown keys. If entry contains extra keys, preserve them.

### Step D: Recompute derived fields (optional)

* `generated_at` update to now (or to SOURCE_DATE_EPOCH if you support determinism server-side)
* `workflow` should remain unchanged, or if you want, set to `config.workflow` if present

Recommendation: leave workflow alone unless you are sure.

### Step E: Deterministic re-sort tickets

Sort with stable ordering:

State order map:

* backlog: 0
* ready: 1
* in_progress: 2
* blocked: 3
* done: 4

Unknown states sort after known states.

Priority order map:

* p0: 0
* p1: 1
* p2: 2
* p3: 3

Unknown priorities sort after known priorities.

Comparator:

1. state rank
2. priority rank
3. `id` lexicographic (string compare)

### Step F: Serialize

Serialize with stable formatting:

* JSON stringify with 2-space indentation (readable) or minified (smaller). Pick one and stick.

Recommendation: 2-space indent for diffs.

Return the JSON string.

## Error mapping

* `index_invalid_format` -> show "index.json is corrupted. Run `ticket rebuild-index` and push."
* `index_missing_ticket_entry` -> show "index.json is out of sync. Run `ticket rebuild-index` and push."

---

# GitHub API Call Sequence (Octokit-style)

## Overview flow

Create a PR that updates:

* `.tickets/tickets/<ULID>.md`
* `.tickets/index.json`

Steps:

1. Determine default branch and latest SHA
2. Create a new branch for the ticket-change PR
3. Fetch the current versions of the ticket file and index.json
4. Apply patches (frontmatter + index patch)
5. Commit both updated files to the new branch
6. Create PR
7. Optionally enable auto-merge (if allowed by policy)

## Required GitHub permissions

For the GitHub App or OAuth token:

* read access to repository contents
* write access to repository contents (to create branch and commit)
* pull request write (to create PR)
* optional auto-merge permission (GitHub setting dependent)

If any permission is missing, return `github_permission_denied`.

## API sequence details

### A) Determine repo and default branch

Use REST:

1. Get repository metadata
   * `GET /repos/{owner}/{repo}`

Returns:

* `default_branch`

2. Get latest commit SHA of default branch

Option 1:

* `GET /repos/{owner}/{repo}/git/ref/heads/{default_branch}`

Returns:

* `object.sha` (commit SHA)

Call this `baseSha`.

### B) Create PR branch ref

Branch name:

* `ticket-change/<short_id>/<timestamp>`

Example:

* `ticket-change/01arz3nd/20260217-183000`

Create ref:

* `POST /repos/{owner}/{repo}/git/refs`

Body:

```json
{
  "ref": "refs/heads/ticket-change/01arz3nd/20260217-183000",
  "sha": "<baseSha>"
}
```

If ref exists (rare), append a random suffix and retry once.

### C) Fetch file contents from default branch

Fetch ticket file:

* `GET /repos/{owner}/{repo}/contents/.tickets/tickets/<ULID>.md?ref=<default_branch>`

Fetch index.json:

* `GET /repos/{owner}/{repo}/contents/.tickets/index.json?ref=<default_branch>`

Each returns:

* `content` base64
* `sha` (blob sha) for that file in that branch

Decode base64 to raw strings:

* `rawTicket`
* `rawIndex`

If index.json missing:

* fail with `index_missing` and instruct user to run CLI rebuild.

### D) Apply patches locally (server-side)

1. `newRawTicket = patchTicketFrontmatter(rawTicket, patch)`
2. `newRawIndex = patchIndexJson(rawIndex, ticketId, patch)`

If any validation error:

* return appropriate error code, do not create PR.

### E) Commit updated files to PR branch

#### Option 2 (recommended): create one commit with a tree update

Do a single commit that updates both files.

Sequence:

1. Get base commit object
   * `GET /repos/{owner}/{repo}/git/commits/{baseSha}`

Returns:

* `tree.sha` (call it `baseTreeSha`)

2. Create blobs for new file contents
   * `POST /repos/{owner}/{repo}/git/blobs`

Body:

```json
{
  "content": "<newRawTicket>",
  "encoding": "utf-8"
}
```

Returns `ticketBlobSha`

Repeat for index:

Returns `indexBlobSha`

3. Create a new tree with updated paths
   * `POST /repos/{owner}/{repo}/git/trees`

Body:

```json
{
  "base_tree": "<baseTreeSha>",
  "tree": [
    {
      "path": ".tickets/tickets/<ULID>.md",
      "mode": "100644",
      "type": "blob",
      "sha": "<ticketBlobSha>"
    },
    {
      "path": ".tickets/index.json",
      "mode": "100644",
      "type": "blob",
      "sha": "<indexBlobSha>"
    }
  ]
}
```

Returns `newTreeSha`

4. Create a new commit pointing to that tree
   * `POST /repos/{owner}/{repo}/git/commits`

Body:

```json
{
  "message": "[TK-<short_id>] ticket change: <summary>",
  "tree": "<newTreeSha>",
  "parents": ["<baseSha>"]
}
```

Returns `newCommitSha`

5. Update branch ref to new commit
   * `PATCH /repos/{owner}/{repo}/git/refs/heads/ticket-change/01arz3nd/20260217-183000`

Body:

```json
{
  "sha": "<newCommitSha>",
  "force": false
}
```

Now the branch has exactly one commit with both changes.

### F) Create the pull request

* `POST /repos/{owner}/{repo}/pulls`

Body:

```json
{
  "title": "[TK-01ARZ3ND] ticket change: ready â†’ in_progress",
  "head": "ticket-change/01arz3nd/20260217-183000",
  "base": "<default_branch>",
  "body": "Generated by ticket.app dashboard.\n\nTicket: /space/<owner>/<repo>/t/TK-01ARZ3ND\n\nChanges:\n- state: ready â†’ in_progress\n"
}
```

Returns:

* PR number
* PR URL

### G) Optional: enable auto-merge

Auto-merge is only possible if:

* repo allows auto-merge
* branch protection and required reviews allow it
* token has permission

You can:

1. Check PR mergeability and requirements
   * `GET /repos/{owner}/{repo}/pulls/{pull_number}`

Fields:

* `mergeable` (can be null initially)
* `mergeable_state` (e.g. clean, blocked, dirty)

Because mergeable can be computed asynchronously, poll a few times with backoff.

2. Enable auto-merge (GraphQL)

GitHub's auto-merge enablement is typically via GraphQL `enablePullRequestAutoMerge`.

GraphQL outline:

* Query PR node ID
* Mutation:
  * `enablePullRequestAutoMerge(input: { pullRequestId: <id>, mergeMethod: SQUASH })`

If fails due to policy:

* leave PR open
* UI shows "Waiting for review" or "Waiting for checks"

Do not attempt to merge directly unless explicitly configured.

## PR status polling (for UI "pending")

Dashboard should poll PR status for pending changes:

* checks status (combined)
* review status (required approvals)
* mergeability state
* merged state

Polling interval:

* 15 to 30 seconds for pending PRs only.

When PR merged:

* refresh index.json
* clear pending badge
* canonical state updates

If PR closed without merge:

* mark pending as "failed" and show link.

## Error codes returned to UI

* `github_permission_denied`
* `index_missing`
* `index_invalid_format`
* `index_missing_ticket_entry`
* `frontmatter_missing`
* `frontmatter_invalid_yaml`
* `invalid_transition`
* `invalid_actor`
* `invalid_label`
* `pr_create_failed`
* `branch_create_failed`
* `commit_failed`

UI must map errors to:

* clear message
* suggested recovery
* link to GitHub where helpful

---

# Acceptance Criteria (v1.1)

1. Drag ticket `ready â†’ in_progress` creates a PR that updates:
   * ticket file frontmatter
   * index.json entry
2. UI shows pending badge and PR link immediately
3. When PR merges, ticket moves column automatically within 30 seconds (polling ok)
4. Invalid transitions are blocked client-side and server-side
5. Inline edits (priority, labels, assignee, reviewer) create PRs and update UI pending
6. Auto-merge enabled only when allowed; never bypasses branch protection
7. All changes preserve unknown frontmatter keys and x_ticket semantically
8. If index.json is missing or out of sync, the UI shows a clear recovery message:
   * "Run `ticket rebuild-index` and push, then retry"
