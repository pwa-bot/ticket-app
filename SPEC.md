# ticket.app v1.0.2 SPEC

## Git-native issue tracking for AI-first teams

---

### Table of Contents

**Protocol**
- [§1 What It Is](#1-what-it-is) — Core principles
- [§2 Repo Layout](#2-repo-layout-source-of-truth) — File structure
- [§3 Ticket Format](#3-ticket-file-format) — Frontmatter, fields, parsing
- [§4 Workflow](#4-workflow-v1-hardcoded) — State machine
- [§5 Configuration](#5-configuration) — config.yml, policy.yml
- [§6 Template](#6-template) — Default ticket structure
- [§7 Index File](#7-index-file) — index.json schema

**CLI**
- [§8 CLI Specification](#8-cli-specification) — Commands, flags, behavior
- [§9 Git Hooks](#9-git-hooks) — Pre-commit validation
- [§10 PR Linking](#10-pr-linking) — Branch/PR conventions

**Web**
- [§11 Web Dashboard](#11-web-dashboard-v1-read-only) — Features, OAuth, views

**Business**
- [§12 Monetization](#12-monetization) — Pricing tiers
- [§13 Tech Stack](#13-tech-stack) — Implementation details
- [§14 Security](#14-security-v1) — OAuth, data handling
- [§15 MVP Scope](#15-mvp-scope) — What's in/out of v1

**Integration**
- [§16 Agent Usage](#16-agent-usage-openclaw) — OpenClaw integration
- [§17 Link Schemes](#17-link-schemes-reserved) — URI format
- [§18 Data Governance](#18-data-governance) — Privacy, PII
- [§19 Future Extensibility](#19-future-extensibility-reserved-not-built) — Reserved hooks

---

## 1. What It Is

Ticket is a Git-native issue tracking protocol where tickets live as markdown files in your repository, operated by a CLI (agent interface), with a web dashboard (human interface) that reads the repo.

### Core Principles

- Git is the source of truth
- Markdown is the UI
- YAML frontmatter is structured state
- CLI is the agent interface
- Web dashboard is the human interface
- Never block local usage
- Never per-seat billing
- Monetize coordination, not storage

---

## 2. Repo Layout (Source of Truth)

```
.tickets/
  config.yml
  template.md
  index.json
  tickets/
    01ARZ3NDEKTSV4RRFFQ69G5FAV.md
    01ARZ3P9E4C1N2EXAMPLE.md
```

Rules:
- `.tickets/tickets/*.md` are the only canonical ticket files
- `.tickets/index.json` is **derived** and must be regenerated by the CLI on every mutation
- The web app only needs `index.json` plus individual ticket files on demand

---

## 3. Ticket File Format

### 3.1 Filename

- Filename stem is the canonical ID
- Use full ULID, 26 chars, uppercase
- Example: `01ARZ3NDEKTSV4RRFFQ69G5FAV.md`

### 3.2 Frontmatter (Minimal and Strict)

```markdown
---
id: 01ARZ3NDEKTSV4RRFFQ69G5FAV
title: Add paywall experiment
state: ready
priority: p1
labels: [growth, onboarding]
---

## Problem

Describe the problem and context.

## Acceptance Criteria

- [ ] Criterion one
- [ ] Criterion two

## Spec

Keep small specs inline. Link longer docs if needed.

## Notes

Any extra context, links, screenshots.
```

### 3.3 Required Fields

| Field | Type | Rules |
|-------|------|-------|
| `id` | string | Must match filename stem exactly |
| `title` | string | Non-empty |
| `state` | enum | Lowercase: backlog, ready, in_progress, blocked, done |
| `priority` | enum | Lowercase: p0, p1, p2, p3 |

### 3.4 Optional Fields

| Field | Type | Rules |
|-------|------|-------|
| `labels` | array | Lowercase strings. Always include as `labels: []` if empty. |
| `assignee` | string | Actor responsible for implementation. Format: `human:<slug>` or `agent:<slug>`. |
| `reviewer` | string | Actor responsible for PR review. Format: `human:<slug>` or `agent:<slug>`. |
| `author` | string | Actor who created the ticket. Format: `human:<slug>` or `agent:<slug>`. Can be derived from git blame. |
| `x_ticket.qa.required` | boolean | Enables QA gate when `true`. |
| `x_ticket.qa.status` | enum | `pending_impl`, `ready_for_qa`, `qa_failed`, `qa_passed` (required when `x_ticket.qa.required=true`). |
| `x_ticket.qa.status_reason` | string | Required when `x_ticket.qa.status=qa_failed`. |
| `x_ticket.qa.environment` | string | Required when `x_ticket.qa.status=ready_for_qa` or `qa_passed`. |

### 3.4.1 Actor Format

Actors follow the convention `<type>:<slug>`:
- `human:morgan` — a person
- `human:mathieu` — another person
- `agent:openclaw` — an AI agent
- `agent:codex` — another AI agent

In v1, these are opaque strings. The CLI treats them as labels. Web can filter on them. Later versions may map to GitHub usernames or team memberships.

### 3.5 Derived Fields (Not Stored)

| Field | Source |
|-------|--------|
| `created_at` | First commit where file appears |
| `updated_at` | Latest commit touching file |

### 3.6 Strict Parsing Rules

- UTF-8 only
- Frontmatter delimiter is exactly `---` on its own line, both start and end
- YAML must parse cleanly, no tabs
- `state` and `priority` must be lowercase
- `id` must match filename stem exactly (case-sensitive)
- Unknown top-level keys are ignored unless under `x_ticket`
- When `x_ticket.qa.required=true`, `state: done` is invalid unless `x_ticket.qa.status=qa_passed`

### 3.7 Invalid Ticket Handling

- CLI `validate`: fails with non-zero exit
- Web: shows "Invalid ticket format" badge, still displays raw markdown

### 3.8 Future Extension Namespace (Reserved, Ignored in v1)

```yaml
x_ticket:
  qa:
    required: true
    status: pending_impl
  source:
    kind: intake
    id: in_01J...
  relations:
    blocks: []
    blocked_by: []
  last_run_id: run_01J...
  enforcement:
    required_reviews: 1
```

**Reserved fields under `x_ticket`:**

| Field | Future Purpose |
|-------|----------------|
| `source` | Link to intake/feedback system (`kind` + `id`) |
| `relations` | Dependency tracking (`blocks`, `blocked_by`) |
| `last_run_id` | Agent run trace reference |
| `enforcement` | Per-ticket policy overrides |
| `qa` | QA signaling and done-gate metadata |

**Rules:**
- v1 CLI validates and updates `x_ticket.qa` when present
- v1 Web may render `x_ticket` without enforcing QA transitions
- Never store PII (names, emails, screenshots) in ticket files
- External references use `ticket://` URIs (see §17)

---

## 4. Workflow (v1 Hardcoded)

### States

| State | Description |
|-------|-------------|
| `backlog` | Not ready to work |
| `ready` | Specced, ready to start |
| `in_progress` | Actively being worked |
| `blocked` | Waiting on external dependency |
| `done` | Complete |

### Transitions

```
backlog → ready
ready → in_progress
in_progress → done
any → blocked
blocked → ready
blocked → in_progress
```

### QA Signaling Overlay (`x_ticket.qa`)

QA lifecycle is tracked as extension metadata without changing canonical workflow states:

1. Implementation start: `state=in_progress`, `x_ticket.qa.status=pending_impl`
2. QA handoff: `state=in_progress`, `x_ticket.qa.status=ready_for_qa`, `x_ticket.qa.environment=<env>`
3. QA fail: `state=in_progress`, `x_ticket.qa.status=qa_failed`, `x_ticket.qa.status_reason=<reason>`
4. Rework: `state=in_progress`, `x_ticket.qa.status=pending_impl`
5. QA pass: `state=in_progress`, `x_ticket.qa.status=qa_passed`, `x_ticket.qa.environment=<env>`
6. Completion gate: `state=done` allowed only after QA pass when `x_ticket.qa.required=true`

### Terminal State

- `done` is terminal in v1, no reopen
- Tickets in `done` remain in `.tickets/tickets/` permanently
- No archive folder, no automatic moves
- Git history is the archive

---

## 5. Configuration

### `.tickets/config.yml`

```yaml
format_version: 1
id_prefix: TK
directory: .tickets/tickets
workflow: simple-v1

linking:
  branch_pattern: "tk-{short_id}-{slug}"
  pr_title_pattern: "[{display_id}] {title}"
```

### ID Definitions

| Term | Definition | Example |
|------|------------|---------|
| `id` | Full ULID (26 chars) | `01ARZ3NDEKTSV4RRFFQ69G5FAV` |
| `short_id` | First 8 chars of ULID | `01ARZ3ND` |
| `display_id` | Deterministic v2 display id (`TK-<short_id>`; on collision: `TK-<short_id>-<seq>`) | `TK-01ARZ3ND`, `TK-01ARZ3ND-2` |

### `.tickets/policy.yml` (Optional)

Merge and approval policy. Separate from config to keep core format clean. Policy is optional — without it, agent uses sensible defaults (require human review for p0/p1).

```yaml
version: 1

merge_policy:
  default: review_required

  rules:
    - match:
        priority: [p3]
        labels_any: [polish, chore]
      policy: auto_merge_on_green

    - match:
        priority: [p0, p1]
      policy: require_approvals
      approvers: [human:morgan, human:mathieu]

approvers:
  human:morgan:
    can_approve: [p0, p1, p2, p3]
  human:mathieu:
    can_approve: [p0, p1, p2, p3]
  agent:openclaw:
    can_approve: [p3]  # Only low-risk tickets
```

### Merge Policies

| Policy | Behavior |
|--------|----------|
| `auto_merge_on_green` | Agent merges (or enables GitHub auto-merge) when CI passes |
| `review_required` | Requires at least one approval before merge |
| `require_approvals` | Requires approval from specific actors in `approvers` list |

### Policy Enforcement

- **v1**: Policy is advisory. Agent respects it behaviorally.
- **v1.1+**: GitHub check validates policy before allowing merge.

Enforcement uses GitHub primitives (branch protection, CODEOWNERS, required reviews) — ticket.app does not reinvent these.

---

## 6. Template

### `.tickets/template.md`

Used by `ticket new`. Contains placeholders replaced by CLI.

```markdown
---
id: {{id}}
title: {{title}}
state: {{state}}
priority: {{priority}}
labels: []
---

## Problem

Describe the problem and context.

## Acceptance Criteria

- [ ] 

## Spec

Keep small specs inline. Link longer docs if needed.

## Notes

Any extra context, links, screenshots.
```

Rules:
- CLI replaces `{{placeholders}}`
- `labels` always included as `labels: []` for parsing predictability

---

## 7. Index File

### `.tickets/index.json` (Derived, Generated by CLI)

#### Purpose

- Makes the web dashboard fast and "no database" feasible
- Avoids GitHub API pagination and per-file parsing

#### Format

```json
{
  "format_version": 1,
  "generated_at": "2026-02-16T18:22:11Z",
  "workflow": "simple-v1",
  "tickets": [
    {
      "id": "01ARZ3NDEKTSV4RRFFQ69G5FAV",
      "short_id": "01ARZ3ND",
      "display_id": "TK-01ARZ3ND",
      "title": "Add paywall experiment",
      "state": "ready",
      "priority": "p1",
      "labels": ["growth", "onboarding"],
      "assignee": "human:morgan",
      "reviewer": "agent:openclaw",
      "qa_required": true,
      "qa_status": "ready_for_qa",
      "path": ".tickets/tickets/01ARZ3NDEKTSV4RRFFQ69G5FAV.md",
      "extras": {
        "source_kind": "intake",
        "source_id": "in_01J..."
      }
    }
  ]
}
```

**Field notes:**
- `assignee`, `reviewer`: Included if set in ticket frontmatter (for web filtering)
- `qa_required`, `qa_status`: Included when QA extension metadata is set in frontmatter
- `extras`: Optional object for future extension data (v1 ignores, v2+ can filter/group)

#### Regeneration Triggers

- `ticket new`
- `ticket move` / `ticket start` / `ticket done`
- `ticket edit` (if frontmatter changes)
- `ticket rebuild-index`

#### Deterministic Sorting

To avoid noisy diffs:
1. Primary: state order (backlog, ready, in_progress, blocked, done)
2. Secondary: priority (p0, p1, p2, p3)
3. Tertiary: id (lexicographic)

---

## 8. CLI Specification

Binary: `ticket`

### 8.1 Modes

| Mode | Behavior |
|------|----------|
| Interactive (default) | Deterministic resolution with explicit ambiguity errors |
| `--ci` | Same deterministic resolution; no fuzzy matching |

In `--ci` mode:
- IDs are resolved in precedence order: full `id` > exact `display_id` > unique `short_id`
- Any ambiguity is an error with non-zero exit
- `ticket edit` returns non-zero with `code=ci_mode_not_supported`

### 8.2 Commands

| Command | Description |
|---------|-------------|
| `ticket init` | Create `.tickets/` structure, config.yml, template.md, empty index.json |
| `ticket new "Title" [--priority p1] [--state backlog] [--label x]` | Create ticket with ULID, regenerate index, auto-commit |
| `ticket list [--state x] [--qa-status x] [--priority x] [--label x]` | List tickets from index.json, including QA indicator/filter |
| `ticket show <id>` | Display ticket details using deterministic id resolution |
| `ticket move <id> <state>` | Transition state, validate, regenerate index, auto-commit |
| `ticket start <id>` | Shortcut for `move <id> in_progress` |
| `ticket done <id>` | Shortcut for `move <id> done` (blocked if QA required and not passed) |
| `ticket qa ready <id> --env <value>` | Set `x_ticket.qa.status=ready_for_qa` |
| `ticket qa fail <id> --reason "<reason>"` | Set `x_ticket.qa.status=qa_failed` |
| `ticket qa pass <id> --env <value>` | Set `x_ticket.qa.status=qa_passed` |
| `ticket qa reset <id>` | Set `x_ticket.qa.status=pending_impl` |
| `ticket edit <id>` | Open in $EDITOR, validate on save, regenerate index, auto-commit |
| `ticket assign <id> <actor>` | Set assignee (e.g., `human:morgan`, `agent:openclaw`) |
| `ticket reviewer <id> <actor>` | Set reviewer for PR |
| `ticket validate [<id>] [--all] [--fix-index]` | Validate tickets, optionally regenerate index |
| `ticket policy [validate]` | Show or validate policy.yml (advisory) |
| `ticket rebuild-index` | Scan all tickets, regenerate index.json |
| `ticket branch <id>` | Print branch name, copy to clipboard if available |
| `ticket install-hooks` | Install git hooks |

### 8.3 Auto-Commit Policy

Commit message format:
- `ticket: create TK-01ARZ3ND Add paywall experiment`
- `ticket: TK-01ARZ3ND → in_progress`
- `ticket: update TK-01ARZ3ND`

Commits include:
- Ticket file changes
- index.json update

### 8.4 Collision and Ambiguity Rules

- ULID prevents filename collisions
- `display_id` v2 is deterministic:
  - Primary: `TK-<first8>`
  - On same-prefix collision: `TK-<first8>-<seq>` with stable sequence by sorted full ULID
- Resolution precedence is strict: full `id` > exact `display_id` > unique `short_id`
- Ambiguous `short_id` is a hard error and returns explicit disambiguation options (`display_id` + full `id`)

---

## 9. Git Hooks

Installed by `ticket install-hooks`:

| Hook | Behavior |
|------|----------|
| pre-commit | Validate changed ticket files |
| pre-push | Validate changed ticket files only |

For repo-wide validation, use `ticket validate --all` in CI.

---

## 10. PR Linking

### Conventions

| Element | Pattern | Example |
|---------|---------|---------|
| Branch | `tk-{short_id}-{slug}` | `tk-01arz3nd-paywall-experiment` |
| PR Title | `[{display_id}] {title}` | `[TK-01ARZ3ND] Add paywall experiment` |

### Auto-Link Logic

A PR links to a ticket if:
- PR title contains `[TK-01ARZ3ND]`, OR
- Branch name contains `tk-01arz3nd`

Web shows linked PRs on ticket detail page.

---

## 11. Web Dashboard v1 (Read-Only)

### Features

- GitHub OAuth login
- User selects repositories
- Fetch `.tickets/index.json` per repo
- Kanban board view (columns = states)
- List view with filters (state, priority, label, repo)
- Ticket detail view with rendered markdown
- Linked PRs display
- Git history link (GitHub file history)

### Non-Features (v1)

- No editing via web
- No comments (use ticket body or PR)
- No approvals UI (use GitHub PR reviews)

### Refresh Strategy

MVP:
- Manual refresh button
- Optional: polling every N minutes

v1.1:
- GitHub App for automatic webhook installation
- Push events trigger index refresh

No canonical DB. Cache is disposable.

### Dashboard Write Actions (v1.1+)

Dashboard writes are PR-based to maintain Git as source of truth.

**Supported write actions:**
- State transitions (drag-and-drop or dropdown)
- Labels (add/remove)
- Priority (p0–p3)
- Assignee (`human:<slug>` or `agent:<slug>`)
- Reviewer (`human:<slug>` or `agent:<slug>`)

**How it works:**
1. User triggers a write action (e.g., drags ticket to new column)
2. Dashboard creates a PR that modifies:
   - `.tickets/tickets/<ULID>.md` (frontmatter only)
   - `.tickets/index.json` (patched entry, re-sorted)
3. UI shows "pending" state with PR link
4. When PR merges, canonical state updates
5. If PR conflicts/fails, UI shows error with recovery steps

**UX rules:**
- Ticket stays in original column until PR merges (no optimistic updates)
- Pending badge shows: `ready → in_progress (pending)`
- Recovery message for index issues: "Run `ticket rebuild-index` and push, then retry"

**Auto-merge policy:**
- Enabled only when repo allows auto-merge AND no required reviews
- Never bypasses branch protection
- UI shows "Auto-merge enabled" or "Waiting for review"

**Agent behavior:**
- Agents treat default branch as truth (not PR branches)
- Before selecting work: `git pull`, then `ticket list --state ready --json --ci`
- Ignore `ticket-change/` branches unless explicitly asked

Full spec: [docs/DASHBOARD-WRITES-SPEC.md](docs/DASHBOARD-WRITES-SPEC.md)

---

## 12. Monetization

| Tier | Price | Features |
|------|-------|----------|
| Free | $0 | CLI (open source), single-repo web view |
| Pro | $5/repo/mo | Multi-repo dashboard, webhook refresh |
| Team | $20/mo flat | Unlimited repos, Slack notifications |
| Business | $50/mo | GitHub checks for policy, analytics, org controls |

Never per-seat.

Approval philosophy:
- Approvals = GitHub PR reviews + branch protection
- Do not mutate ticket files for approvals in v1

---

## 13. Tech Stack

### CLI

- TypeScript
- Commander.js
- simple-git
- ulid
- gray-matter (frontmatter parsing)
- Vitest (testing)

### Web

- Next.js 14 (App Router)
- Tailwind CSS
- next-auth (GitHub OAuth)
- Octokit (GitHub API)
- Vercel hosting

---

## 14. Security (v1)

### 14.1 GitHub OAuth token handling

- Use GitHub OAuth for user sign-in and repo access.
- Store OAuth access tokens server-side only.
- Tokens must be stored **encrypted at rest**:
  - Use a managed KMS if available (preferred), or
  - Use envelope encryption (AES-256-GCM with per-record nonce) with an app-level master key.
- Never log tokens.
- Only request minimum scopes needed:
  - MVP read-only dashboard: `repo:read` equivalent permissions (exact scopes depend on GitHub OAuth app settings).
- Support token revocation:
  - If GitHub returns 401, mark token invalid and prompt reconnect.

### 14.2 Webhook verification (v1.1)

If using webhooks (not required for MVP), verify all deliveries:

- Verify GitHub webhook signature (HMAC) using the webhook secret.
- Reject requests with:
  - Missing signature headers
  - Invalid signature
- Implement replay protection:
  - Store recent delivery IDs (or event IDs) for 24 hours in a dedupe store.
  - If a delivery ID repeats, ignore it.
  - Apply a timestamp tolerance if GitHub provides a timestamp header (if not, delivery ID dedupe is sufficient).

### 14.3 Least privilege and repo selection

- Web app must only index repositories explicitly selected by the authenticated user/org.
- Do not index all accessible repos by default.
- Store a per-org allowlist of repo IDs.
- If repo permissions change (removed access), remove it from index and show "access lost" in UI.

### 14.4 Data safety boundaries

- The web app is read-only in v1:
  - No ticket mutations via web.
  - No write operations to GitHub aside from optional webhook installation in v1.1 via GitHub App.
- Any future write features must be implemented via PRs or GitHub checks rather than direct file mutations.

### 14.5 Rate limiting

- Apply IP-based rate limiting on OAuth and webhook endpoints.
- Suggested limits:
  - OAuth endpoints: 10 requests/minute per IP
  - Webhook endpoints: 100 requests/minute per IP
- Use standard 429 responses with Retry-After header.

---

## 15. MVP Scope

### CLI (Week 1)

1. `init` + template generation
2. `new` + ULID + file write
3. parse/validate frontmatter
4. `move`/`start`/`done` transitions
5. `index.json` generation
6. `rebuild-index`
7. auto-commit integration
8. `install-hooks`

### Web (Week 1-2)

- GitHub OAuth
- Repo selection
- Fetch index.json
- Kanban board view
- List view with filters
- Ticket detail rendering
- PR linking display (basic)

### Out of Scope

- Editable web UI
- Approvals UI
- Custom workflows
- Slack
- Analytics

---

## 16. Agent Usage (OpenClaw)

Instructions for any OpenClaw instance:

1. Clone repo
2. Ensure `ticket` CLI available
3. Use CLI commands (preferred) or edit files directly
4. CLI regenerates index.json automatically
5. Push changes

Agent-safe usage:
- Always use `--ci` mode
- Prefer full `id` or exact `display_id`; use `short_id` only when unique
- Avoid fuzzy matching in automation

Optional skill wrapper:
- `ticket` skill calls CLI actions and pushes commits

### PR Comment Commands

Agents monitor PR comments for mentions. Deterministic command grammar:

| Command | Action |
|---------|--------|
| `@openclaw fix lint` | Fix linting errors, push commit |
| `@openclaw implement requested changes` | Address review feedback |
| `@openclaw rebase and update` | Rebase on main, resolve conflicts |
| `@openclaw merge when green` | Enable auto-merge or merge when CI passes |

Agent always replies with:
1. What action it will take
2. Link to commit(s) pushed
3. What is still pending (tests, review)

### Agent Policy Behavior

Agent reads `.tickets/policy.yml` to determine behavior:

- **auto_merge_on_green**: Agent merges or enables GitHub auto-merge when CI passes
- **review_required**: Agent waits for human approval, pings reviewer if stale
- **require_approvals**: Agent waits for specific approvers, does not bypass

Policy is advisory in v1. GitHub branch protection provides hard enforcement.

---

## 17. Link Schemes (Reserved)

Standard URI formats for cross-referencing:

| Scheme | Purpose | Example |
|--------|---------|---------|
| `ticket://<repo>/<id>` | Link to ticket in repo | `ticket://pwa-bot/fasting-app/01ARZ3ND` |
| `ticket://intake/<id>` | Link to intake object (future) | `ticket://intake/in_01J...` |

**Usage in ticket body:**

```markdown
## Source

Intake: ticket://intake/in_01J...
```

**Rules:**
- v1 treats these as plain text
- v2+ web may render as clickable links
- Prefer body `## Source` section over `x_ticket.source` for human readability

---

## 18. Data Governance

### 18.1 No PII in Repository

Ticket files must **never** contain:
- Raw user emails
- User real names (unless public contributors)
- Screenshots with PII
- Support conversation transcripts

If intake/feedback systems exist (future), they store PII in hosted overlay with proper retention policies. Ticket files contain only:
- Sanitized summary
- Reference URI (`ticket://intake/<id>`)

### 18.2 Repository is Source of Truth

The web dashboard caches and indexes but **never stores authoritative state**.

- All ticket state lives in `.tickets/` files
- Web cache is disposable — can be rebuilt from repo
- If web cache and repo disagree, repo wins

### 18.3 Future Write Operations Must Be PR-Based

One-way door to avoid: server directly editing ticket files on `main`.

When/if web writes are added:
- Web creates PRs that add/edit ticket files
- Merge applies the change
- Git history remains the audit trail
- No "shadow writes" that bypass git

This ensures:
- Full audit trail via `git log`
- Branch protection still applies
- Human review possible for any mutation

---

## 19. Future Extensibility (Reserved, Not Built)

These features are **not in v1** but the format preserves the path:

| Feature | Hook Reserved |
|---------|---------------|
| In-app feedback intake | `x_ticket.source`, `ticket://intake/` |
| Cross-repo portfolio | Web supports multi-repo from day 1 |
| Ticket relations | `x_ticket.relations.blocks`, `blocked_by` |
| Agent run traces | `x_ticket.last_run_id` |
| Attachments | `## Links` body section (link, don't embed) |
| Custom workflows | `workflow` field in config.yml |

**Principle:** Reserve extension points now. Do not add product surface area now.

---

End of spec.
